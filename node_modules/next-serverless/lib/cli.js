"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.executeCommand = exports.findNext = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _crossSpawn = require("cross-spawn");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Find the path where next.js is installed
 *
 * @return {string} next.js location
 */
const findNext = () => {
  const possiblePaths = ['../node_modules/next', // local development with npm link
  '../../next'];
  const nextPath = possiblePaths.find(p => _fs.default.existsSync(_path.default.resolve(__dirname, p)));

  if (!nextPath) {
    throw new Error('next could not be found, make sure it is installed');
  }

  return _path.default.resolve(__dirname, nextPath);
};
/**
 * Executes a command and handles exit codes correctly
 *
 * @param {string} command - Command to execute
 * @param {array} args - Arguments to pass to the command
 * @param {object} options - Options for the new process
 * @return {Promise} If `stdio` is set to 'pipe', returns a promise which contains the output
 */


exports.findNext = findNext;

const executeCommand = (command, args = [], options = {}) => {
  const proc = (0, _crossSpawn.spawn)(command, args, _objectSpread({
    stdio: 'inherit',
    customFds: [0, 1, 2]
  }, options)); // handle process output

  let stdout = '';
  let stderr = '';
  let promise;
  const outputPromise = new Promise((resolve, reject) => {
    promise = {
      resolve,
      reject
    };
  });

  if (options.stdio === 'pipe') {
    proc.stdout.on('data', data => {
      stdout += data;
    });
    proc.stderr.on('data', data => {
      stderr += data;
    });
  } // handle process close


  proc.on('close', (code, signal) => {
    if (options.stdio === 'pipe') {
      if (stderr === '') {
        promise.resolve(stdout);
      } else {
        promise.reject(stderr);
      }
    } // wait for promises to resolve


    setTimeout(() => {
      if (code !== null) {
        process.exit(code);
      } else if (signal && signal === 'SIGKILL') {
        process.exit(137);
      } else if (signal) {
        process.exit(1);
      }

      process.exit(0);
    });
  });
  proc.on('error', err => {
    console.error(err);
    process.exit(1);
  });
  process.on('SIGINT', proc.kill);
  process.on('SIGTERM', proc.kill);
  process.on('exit', proc.kill);
  return outputPromise;
};

exports.executeCommand = executeCommand;